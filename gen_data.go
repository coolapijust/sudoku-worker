//go:build ignore

// gen_data.go - 预计算数据生成工具
// 运行: go run gen_data.go
// 生成: data_generated.go

package main

import (
	"fmt"
	"os"
)

const (
	numGrids         = 288
	numHintPositions = 1820
	maxHintsPerByte  = 50
	decodeTableSize  = 8192
)

type Grid [16]uint8

var (
	allGridsData      [numGrids][16]uint8
	hintPositionsData [numHintPositions][4]uint8
	encodeTable       [256][maxHintsPerByte][4]uint8
	encodeTableCount  [256]uint8
	decodeTableKeys   [decodeTableSize]uint32
	decodeTableVals   [decodeTableSize]uint8
)

func initGrids() {
	var g Grid
	gridCount := 0

	var backtrack func(int)
	backtrack = func(idx int) {
		if idx == 16 {
			allGridsData[gridCount] = g
			gridCount++
			return
		}
		row, col := idx/4, idx%4
		br, bc := (row/2)*2, (col/2)*2
		for num := uint8(1); num <= 4; num++ {
			valid := true
			for i := 0; i < 4; i++ {
				if g[row*4+i] == num || g[i*4+col] == num {
					valid = false
					break
				}
			}
			if valid {
				for r := 0; r < 2; r++ {
					for c := 0; c < 2; c++ {
						if g[(br+r)*4+(bc+c)] == num {
							valid = false
							break
						}
					}
				}
			}
			if valid {
				g[idx] = num
				backtrack(idx + 1)
				g[idx] = 0
			}
		}
	}
	backtrack(0)
}

func initHintPositions() {
	idx := 0
	for a := uint8(0); a < 13; a++ {
		for b := a + 1; b < 14; b++ {
			for c := b + 1; c < 15; c++ {
				for d := c + 1; d < 16; d++ {
					hintPositionsData[idx] = [4]uint8{a, b, c, d}
					idx++
				}
			}
		}
	}
}

func initCodecTables() {
	var seed uint64 = 0x7375646F6B75
	rngState := uint32(seed ^ (seed >> 32))

	rngNext := func() uint32 {
		rngState = rngState*1664525 + 1013904223
		return rngState
	}

	var gridOrder [numGrids]uint16
	for i := 0; i < numGrids; i++ {
		gridOrder[i] = uint16(i)
	}
	for i := numGrids - 1; i > 0; i-- {
		j := rngNext() % uint32(i+1)
		gridOrder[i], gridOrder[j] = gridOrder[j], gridOrder[i]
	}

	for byteVal := 0; byteVal < 256; byteVal++ {
		count := uint8(0)
		for hpIdx := 0; hpIdx < numHintPositions && count < maxHintsPerByte; hpIdx++ {
			hp := hintPositionsData[hpIdx]
			valid := true
			var hints [4]uint8
			for i := 0; i < 4; i++ {
				gridIdx := gridOrder[hpIdx%numGrids]
				cellIdx := hp[i]
				hints[i] = allGridsData[gridIdx][cellIdx]
				if hints[i] == 0 {
					valid = false
					break
				}
			}
			if !valid {
				continue
			}
			key := packHints(hints)
			_, found := decodeTableLookup(key)
			if !found {
				encodeTable[byteVal][count] = hints
				decodeTableInsert(key, uint8(byteVal))
				count++
			}
		}
		encodeTableCount[byteVal] = count
	}
}

func packHints(hints [4]uint8) uint32 {
	return uint32(hints[0])<<24 | uint32(hints[1])<<16 | uint32(hints[2])<<8 | uint32(hints[3])
}

func decodeTableInsert(key uint32, val uint8) {
	hash := key & (decodeTableSize - 1)
	for i := 0; i < decodeTableSize; i++ {
		if decodeTableKeys[hash] == 0 {
			decodeTableKeys[hash] = key
			decodeTableVals[hash] = val
			return
		}
		hash = (hash + 1) & (decodeTableSize - 1)
	}
}

func decodeTableLookup(key uint32) (uint8, bool) {
	hash := key & (decodeTableSize - 1)
	for i := 0; i < decodeTableSize; i++ {
		if decodeTableKeys[hash] == key {
			return decodeTableVals[hash], true
		}
		if decodeTableKeys[hash] == 0 {
			return 0, false
		}
		hash = (hash + 1) & (decodeTableSize - 1)
	}
	return 0, false
}

func main() {
	fmt.Println("[GEN] Starting data generation...")

	initGrids()
	fmt.Println("[GEN] Generated", numGrids, "grids")

	initHintPositions()
	fmt.Println("[GEN] Generated", numHintPositions, "hint positions")

	initCodecTables()
	fmt.Println("[GEN] Generated codec tables")

	f, err := os.Create("data_generated.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by gen_data.go; DO NOT EDIT.")
	fmt.Fprintln(f, "package main")
	fmt.Fprintln(f)

	// allGridsData
	fmt.Fprintln(f, "var allGridsData = [numGrids][16]uint8{")
	for i := 0; i < numGrids; i++ {
		fmt.Fprintf(f, "\t{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d},\n",
			allGridsData[i][0], allGridsData[i][1], allGridsData[i][2], allGridsData[i][3],
			allGridsData[i][4], allGridsData[i][5], allGridsData[i][6], allGridsData[i][7],
			allGridsData[i][8], allGridsData[i][9], allGridsData[i][10], allGridsData[i][11],
			allGridsData[i][12], allGridsData[i][13], allGridsData[i][14], allGridsData[i][15])
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	// hintPositionsData
	fmt.Fprintln(f, "var hintPositionsData = [numHintPositions][4]uint8{")
	for i := 0; i < numHintPositions; i++ {
		fmt.Fprintf(f, "\t{%d, %d, %d, %d},\n",
			hintPositionsData[i][0], hintPositionsData[i][1],
			hintPositionsData[i][2], hintPositionsData[i][3])
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	// encodeTable
	fmt.Fprintln(f, "var encodeTable = [256][maxHintsPerByte][4]uint8{")
	for i := 0; i < 256; i++ {
		fmt.Fprintln(f, "\t{")
		for j := 0; j < maxHintsPerByte; j++ {
			fmt.Fprintf(f, "\t\t{%d, %d, %d, %d},\n",
				encodeTable[i][j][0], encodeTable[i][j][1],
				encodeTable[i][j][2], encodeTable[i][j][3])
		}
		fmt.Fprintln(f, "\t},")
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	// encodeTableCount
	fmt.Fprintln(f, "var encodeTableCount = [256]uint8{")
	for i := 0; i < 256; i++ {
		if i%16 == 0 {
			fmt.Fprint(f, "\t")
		}
		fmt.Fprintf(f, "%d,", encodeTableCount[i])
		if i%16 == 15 {
			fmt.Fprintln(f)
		}
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	// decodeTableKeys
	fmt.Fprintln(f, "var decodeTableKeys = [decodeTableSize]uint32{")
	for i := 0; i < decodeTableSize; i++ {
		if i%8 == 0 {
			fmt.Fprint(f, "\t")
		}
		fmt.Fprintf(f, "0x%08X,", decodeTableKeys[i])
		if i%8 == 7 {
			fmt.Fprintln(f)
		}
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	// decodeTableVals
	fmt.Fprintln(f, "var decodeTableVals = [decodeTableSize]uint8{")
	for i := 0; i < decodeTableSize; i++ {
		if i%16 == 0 {
			fmt.Fprint(f, "\t")
		}
		fmt.Fprintf(f, "%d,", decodeTableVals[i])
		if i%16 == 15 {
			fmt.Fprintln(f)
		}
	}
	fmt.Fprintln(f, "}")

	fmt.Println("[GEN] Generated data_generated.go")
}
